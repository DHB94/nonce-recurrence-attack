#!/usr/bin/env sage

from sage.all import GF, PolynomialRing
import hashlib
import ecdsa
import random
from itertools import permutations

def separator():
    print("-" * 150)


#####################
# global parameters #
#####################

# choose any curve
usedcurve = ecdsa.curves.SECP256k1
# usedcurve = ecdsa.curves.NIST521p
# usedcurve = ecdsa.curves.BRAINPOOLP160r1

print("Selected curve :")
print(usedcurve.name)
separator()

# the private key that will be guessed
g = usedcurve.generator
d = random.randint(1, usedcurve.order - 1)
print("TYPES: ", type(g), type(d))

pubkey = ecdsa.ecdsa.Public_key(g, g * d)
privkey = ecdsa.ecdsa.Private_key(pubkey, d)
print("Private key (decimal):")
print(d)
print("Private key (hexadecimal):")
print(hex(d))
separator()

# N = the number of signatures to use, N >= 4
# the degree of the recurrence relation is N-3
# the number of unknown coefficients in the recurrence equation is N-2
# the degree of the final polynomial in d is 1 + Sum_(i=1)^(i=N-3)i

N = 7
assert N >= 4

############################################################
# nonces and signature generation with recurrence relation #
############################################################

# first, we randomly generate the coefficients of the recurrence relation
a = []
for i in range(N-2):
    a.append(random.randint(1, usedcurve.order - 1))

# then, we generate the N nonces
k = []
# the first one is random
k.append(random.randint(1, usedcurve.order - 1))
# the other ones are computed with the recurrence equation
for i in range(N-1):
    new_k = 0
    for j in range(N-2):
        new_k += a[j] * (k[i] ** j) % usedcurve.order
    k.append(new_k)

# then, we generate the signatures using the nonces
h = []
sgns = []
for i in range(N):
    digest_fnc = hashlib.new("sha256")
    digest_fnc.update(b"recurrence test ")
    digest_fnc.update(i.to_bytes(1, 'big'))
    h.append(digest_fnc.digest())
    # get hash values as integers and comply with ECDSA
    if usedcurve.order.bit_length() < 256:
        h[i] = (int.from_bytes(h[i], "big") >> (256 - usedcurve.order.bit_length())) % usedcurve.order
    else:
        h[i] = int.from_bytes(h[i], "big") % usedcurve.order
    sgns.append(privkey.sign(h[i], k[i]))

# get signature parameters as arrays
s = [sgn.s for sgn in sgns]
r = [sgn.r for sgn in sgns]
s_inv = [ecdsa.numbertheory.inverse_mod(s[i], usedcurve.order) for i in range(N)]


#########################################
# generating the private-key polynomial #
#########################################

# declaring stuff for manipulating polynomials with SAGE
Z = GF(usedcurve.order)
R = PolynomialRing(Z, names=('dd',))
(dd,) = R._first_ngens(1)

# the polynomial we construct will have degree 1 + Sum_(i=1)^(i=N-3)i in dd
# our task here is to compute this polynomial in a constructive way starting from the N signatures in the given list order
# the generic formula will be given in terms of differences of nonces, i.e. k_ij = k_i - k_j where i and j are the signature indexes
# each k_ij is a first-degree polynomial in dd
# this function has the goal of returning it given i and j
def k_ij_poly(i, j, h, r, s_inv):
    hi = Z(h[i])
    hj = Z(h[j])
    s_invi = Z(s_inv[i])
    s_invj = Z(s_inv[j])
    ri = Z(r[i])
    rj = Z(r[j])
    poly = dd * (ri * s_invi - rj * s_invj) + hi * s_invi - hj * s_invj
    return poly

# the idea is to compute the polynomial recursively from the given degree down to 0
# the algorithm is as follows:
# for 4 signatures the second degree polynomial is:
# k_12*k_12 - k_23*k_01
# so we can compute its coefficients.
# the polynomial for N signatures has degree 1 + Sum_(i=1)^(i=N-3)i and can be derived from the one for N-1 signatures

# let's define dpoly(i, j) recursively as the dpoly of degree i starting with index j
def dpoly(n, i, j, h, r, s_inv):
    if i == 0:
        return (k_ij_poly(j + 1, j + 2, h, r, s_inv)) * (k_ij_poly(j + 1, j + 2, h, r, s_inv)) - (k_ij_poly(j + 2, j + 3, h, r, s_inv)) * (k_ij_poly(j + 0, j + 1, h, r, s_inv))
    else:
        left = dpoly(n, i - 1, j, h, r, s_inv)
        for m in range(1, i + 2):
            left = left * (k_ij_poly(j + m, j + i + 2, h, r, s_inv))
        right = dpoly(n, i - 1, j + 1, h, r, s_inv)
        for m in range(1, i + 2):
            right = right * (k_ij_poly(j, j + m, h, r, s_inv))
        return (left - right)

# function to solve for the private key given a specific permutation of signatures
def solve_for_private_key(h_perm, r_perm, s_perm, s_inv_perm):
    poly_target = dpoly(N - 4, N - 4, 0, h_perm, r_perm, s_inv_perm)
    d_guesses = poly_target.roots()
    for root, multiplicity in d_guesses:
        if int(root) == d:  # Convert IntegerMod to int for comparison
            return int(root)  # Convert IntegerMod to int for multiplication
    return None

# try all permutations of the signatures
perms = permutations(range(N))
for perm in perms:
    h_perm = [h[i] for i in perm]
    r_perm = [r[i] for i in perm]
    s_perm = [s[i] for i in perm]
    s_inv_perm = [s_inv[i] for i in perm]

    print(f"\nTrying permutation: {perm}")
    result = solve_for_private_key(h_perm, r_perm, s_perm, s_inv_perm)
    if result is not None:
        print(f"Private key found (decimal): {result}")
        print(f"Private key found (hexadecimal): {hex(result)}")
        
        # Compute the public key from the private key
        pubkey_point = result * g  # result is now a standard Python int
        print("Computed public key (x, y):")
        print(f"x = {pubkey_point.x()} (0x{pubkey_point.x():x})")
        print(f"y = {pubkey_point.y()} (0x{pubkey_point.y():x})")
        break
else:
    print("No valid private key found in all permutations.")
